<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Spring Cloud Stream</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}

</style>
<script type="text/javascript">
function addBlockSwitches() {
	for (var primary of document.querySelectorAll('.primary')) {
		var switchItem = createSwitchItem(primary, createBlockSwitch(primary));
		switchItem.item.classList.add("selected");
		var title = primary.querySelector('.title')
		title.remove();
	}
	for (var secondary of document.querySelectorAll('.secondary')) {
		var primary = findPrimary(secondary);
		if (primary === null) {
			console.error("Found secondary block with no primary sibling");
		}
		else {
			var switchItem = createSwitchItem(secondary, primary.querySelector('.switch'));
			switchItem.content.classList.add("hidden");
			primary.append(switchItem.content);
			secondary.remove();
		}
	}
}

function createElementFromHtml(html) {
	var template = document.createElement('template');
    template.innerHTML = html;
    return template.content.firstChild;
}

function createBlockSwitch(primary) {
    var blockSwitch = createElementFromHtml('<div class="switch"></div>');
    primary.prepend(blockSwitch)
	return blockSwitch;
}

function findPrimary(secondary) {
	var candidate = secondary.previousElementSibling;
	while (candidate != null && !candidate.classList.contains('primary')) {
		candidate = candidate.previousElementSibling;
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	var blockName = block.querySelector('.title').textContent;
	var content = block.querySelectorAll('.content').item(0);
	var colist = nextSibling(block, '.colist');
	if (colist != null) {
		content.append(colist);
	}
	var item = createElementFromHtml('<div class="switch--item">' + blockName + '</div>');
	item.dataset.blockName = blockName;
	content.dataset.blockName = blockName;
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function nextSibling(element, selector) {
	var sibling = element.nextElementSibling;
	while (sibling) {
		if (sibling.matches(selector)) {
			return sibling;
		}
		sibling = sibling.nextElementSibling;
	}
}

function globalSwitch() {
	document.querySelectorAll(".switch--item").forEach(function(item) {
		var blockId = blockIdForSwitchItem(item);
		var handler = function(event) {
			selectedText = event.target.textContent;
			window.localStorage.setItem(blockId, selectedText);
			for (var switchItem of document.querySelectorAll(".switch--item")) {
				if (blockIdForSwitchItem(switchItem) === blockId && switchItem.textContent === selectedText) {
					select(switchItem);
				}
			}
		}
		item.addEventListener("click", handler);
		if (item.textContent === window.localStorage.getItem(blockId)) {
			select(item);
		}
	});
}

function select(selected) {
	for (var child of selected.parentNode.children) {
		child.classList.remove("selected");
	}
	selected.classList.add("selected");
	for (var child of selected.parentNode.parentNode.children) {
		if (child.classList.contains("content")) {
			if (selected.dataset.blockName === child.dataset.blockName) {
				child.classList.remove("hidden");
			}
			else {
				child.classList.add("hidden");
			}
		}
	}	
}

function blockIdForSwitchItem(item) {
	idComponents = []
	for (var switchItem of item.parentNode.querySelectorAll(".switch--item")) {
		idComponents.push(switchItem.textContent.toLowerCase());
	}
	return idComponents.sort().join("-")
}

window.onload = function() {
	addBlockSwitches();
	globalSwitch();
};

</script>

</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#spring-cloud-stream">Spring Cloud Stream</a>
<ul class="sectlevel2">
<li><a href="#_overview">Overview</a></li>
<li><a href="#_configuration">Configuration</a></li>
<li><a href="#_binding_with_functions">Binding with Functions</a></li>
<li><a href="#_binding_with_annotations">Binding with Annotations</a></li>
<li><a href="#_streaming_vs_polled_input">Streaming vs. Polled Input</a></li>
<li><a href="#_sample">Sample</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="spring-cloud-stream"><a class="link" href="#spring-cloud-stream">Spring Cloud Stream</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework on Google Cloud provides a <a href="https://cloud.spring.io/spring-cloud-stream/">Spring Cloud Stream</a> binder to Google Cloud Pub/Sub.</p>
</div>
<div class="paragraph">
<p>The provided binder relies on the <a href="https://github.com/GoogleCloudPlatform/spring-cloud-gcp/tree/main/spring-cloud-gcp-pubsub/src/main/java/com/google/cloud/spring/pubsub/integration">Spring Integration Channel Adapters for Google Cloud Pub/Sub</a>.</p>
</div>
<div class="paragraph">
<p>Maven coordinates, using <a href="getting-started.html#bill-of-materials">Spring Framework on Google Cloud BOM</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;com.google.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-gcp-pubsub-stream-binder&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gradle coordinates:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">dependencies {
    implementation("com.google.cloud:spring-cloud-gcp-pubsub-stream-binder")
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_overview"><a class="link" href="#_overview">Overview</a></h3>
<div class="paragraph">
<p>This binder binds producers to Google Cloud Pub/Sub topics and consumers to subscriptions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Partitioning is currently not supported by this binder.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_configuration"><a class="link" href="#_configuration">Configuration</a></h3>
<div class="paragraph">
<p>You can configure the Spring Cloud Stream Binder for Google Cloud Pub/Sub to automatically generate the underlying resources, like the Google Cloud Pub/Sub topics and subscriptions for producers and consumers.
For that, you can use the <code>spring.cloud.stream.gcp.pubsub.bindings.&lt;channelName&gt;.&lt;consumer|producer&gt;.auto-create-resources</code> property, which is turned ON by default.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.1, these and other binder properties can be configured globally for all the bindings, e.g. <code>spring.cloud.stream.gcp.pubsub.default.consumer.auto-create-resources</code>.</p>
</div>
<div class="paragraph">
<p>If you are using Pub/Sub auto-configuration from the Spring Framework on Google Cloud Pub/Sub Starter, you should refer to the <a href="#pubsub-configuration">configuration</a> section for other Pub/Sub parameters.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To use this binder with a <a href="https://cloud.google.com/pubsub/docs/emulator">running emulator</a>, configure its host and port via <code>spring.cloud.gcp.pubsub.emulator-host</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_producer_synchronous_sending_configuration"><a class="link" href="#_producer_synchronous_sending_configuration">Producer Synchronous Sending Configuration</a></h4>
<div class="paragraph">
<p>By default, this binder will send messages to Cloud Pub/Sub asynchronously.
If synchronous sending is preferred (for example, to allow propagating errors back to the sender), set <code>spring.cloud.stream.gcp.pubsub.default.producer.sync</code> property to <code>true</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_producer_destination_configuration"><a class="link" href="#_producer_destination_configuration">Producer Destination Configuration</a></h4>
<div class="paragraph">
<p>If automatic resource creation is turned ON and the topic corresponding to the destination name does not exist, it will be created.</p>
</div>
<div class="paragraph">
<p>For example, for the following configuration, a topic called <code>myEvents</code> would be created.</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">spring.cloud.stream.bindings.events.destination=myEvents
spring.cloud.stream.gcp.pubsub.bindings.events.producer.auto-create-resources=true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consumer_destination_configuration"><a class="link" href="#_consumer_destination_configuration">Consumer Destination Configuration</a></h4>
<div class="paragraph">
<p>A <code>PubSubInboundChannelAdapter</code> will be configured for your consumer endpoint.
You may adjust the ack mode of the consumer endpoint using the <code>ack-mode</code> property.
The ack mode controls how messages will be acknowledged when they are successfully received.
The three possible options are: <code>AUTO</code> (default), <code>AUTO_ACK</code>, and <code>MANUAL</code>.
These options are described in detail in the <a href="#inbound-channel-adapter-using-pubsub-streaming-pull">Pub/Sub channel adapter documentation</a>.</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs"># How to set the ACK mode of the consumer endpoint.
spring.cloud.stream.gcp.pubsub.bindings.{CONSUMER_NAME}.consumer.ack-mode=AUTO_ACK</code></pre>
</div>
</div>
<div class="paragraph">
<p>With automatic resource creation turned ON for a consumer, the library creates a topic and/or a subscription if they do not exist.
The topic name becomes the same as the destination name, and the subscription name follows these rules (in order of precedence):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A user-defined, pre-existing subscription (use <code>spring.cloud.stream.gcp.pubsub.bindings.{CONSUMER_NAME}.consumer.subscriptionName</code>)</p>
</li>
<li>
<p>A consumer group using the topic name (use <code>spring.cloud.stream.bindings.events.group</code> to create a subscription named <code>&lt;topicName&gt;.&lt;group&gt;</code>)</p>
</li>
<li>
<p>If neither of the above are specified, the library creates an anonymous subscription with the name <code>anonymous.&lt;destinationName&gt;.&lt;randomUUID&gt;</code>.
Then when the binder shuts down, the library automatically cleans up all Pub/Sub subscriptions created for anonymous consumer groups.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, with this configuration:</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">spring.cloud.stream.bindings.events.destination=myEvents
spring.cloud.stream.gcp.pubsub.bindings.events.consumer.auto-create-resources=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only an anonymous subscription named <code>anonymous.myEvents.a6d83782-c5a3-4861-ac38-e6e2af15a7be</code> is created and later cleaned up.</p>
</div>
<div class="paragraph">
<p>In another example, with the following configuration:</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">spring.cloud.stream.bindings.events.destination=myEvents
spring.cloud.stream.gcp.pubsub.bindings.events.consumer.auto-create-resources=true

# specify consumer group, and avoid anonymous consumer group generation
spring.cloud.stream.bindings.events.group=consumerGroup1</code></pre>
</div>
</div>
<div class="paragraph">
<p>These resources will be created:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A topic named <code>myEvents</code></p>
</li>
<li>
<p>A subscription named <code>myEvents.consumerGroup1</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_header_mapping"><a class="link" href="#_header_mapping">Header Mapping</a></h4>
<div class="paragraph">
<p>You can filter incoming and outgoing message headers with <code>allowHeaders</code> property.
For example, for a consumer to allow only two headers, provide a comma separated list like this:</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre>spring.cloud.stream.gcp.pubsub.bindings.&lt;consumerFunction&gt;-in-0.consumer.allowedHeaders=allowed1, allowed2</pre>
</div>
</div>
<div class="paragraph">
<p>Where &lt;consumerFunction&gt; should be replaced by the method which is consuming/reading messages from Cloud Pub/Sub and allowed1, allowed2 is the comma separated list of headers that the user wants to keep.</p>
</div>
<div class="paragraph">
<p>A similar style is applicable for producers as well. For example:</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre>spring.cloud.stream.gcp.pubsub.bindings.&lt;producerFunction&gt;-out-0.producer.allowedHeaders=allowed3,allowed4</pre>
</div>
</div>
<div class="paragraph">
<p>Where &lt;producerFunction&gt; should be replaced by the method which is producing/sending messages to Cloud Pub/Sub and allowed3, allowed4 is the comma separated list of headers that user wants to map. All other headers will be removed before the message is sent to Cloud Pub/Sub.</p>
</div>
</div>
<div class="sect3">
<h4 id="_endpoint_customization"><a class="link" href="#_endpoint_customization">Endpoint Customization</a></h4>
<div class="paragraph">
<p>You may customize channel routing by defining a <code>ConsumerEndpointCustomizer</code> in your autoconfiguration. This is useful if you want to customize the default configurations provided by the Pub/Sub Spring Cloud Stream Binder.</p>
</div>
<div class="paragraph">
<p>The example below demonstrates how to use a <code>ConsumerEndpointCustomizer</code> to override the default error channel configured by the binder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public ConsumerEndpointCustomizer&lt;PubSubInboundChannelAdapter&gt; messageChannelAdapter() {
    return (endpoint, destinationName, group) -&gt; {
        NamedComponent namedComponent = (NamedComponent) endpoint.getOutputChannel();
        String channelName = namedComponent.getBeanName();
        endpoint.setErrorChannelName(channelName + ".errors");
    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_binding_with_functions"><a class="link" href="#_binding_with_functions">Binding with Functions</a></h3>
<div class="paragraph">
<p>Since version 3.0, Spring Cloud Stream supports a functional programming model natively.
This means that the only requirement for turning your application into a sink is presence of a <code>java.util.function.Consumer</code> bean in the application context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">@Bean
public Consumer&lt;UserMessage&gt; logUserMessage() {
  return userMessage -&gt; {
    // process message
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A source application is one where a <code>Supplier</code> bean is present.
It can return an object, in which case Spring Cloud Stream will invoke the supplier repeatedly.
Alternatively, the function can return a reactive stream, which will be used as is.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">@Bean
Supplier&lt;Flux&lt;UserMessage&gt;&gt; generateUserMessages() {
  return () -&gt; /* flux creation logic */;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A processor application works similarly to a source application, except it is triggered by presence of a <code>Function</code> bean.</p>
</div>
</div>
<div class="sect2">
<h3 id="_binding_with_annotations"><a class="link" href="#_binding_with_annotations">Binding with Annotations</a></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of version 3.0, annotation binding is considered legacy.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To set up a sink application in this style, you would associate a class with a binding interface, such as the built-in <code>Sink</code> interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">@EnableBinding(Sink.class)
public class SinkExample {

	@StreamListener(Sink.INPUT)
	public void handleMessage(UserMessage userMessage) {
		// process message
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To set up a source application, you would similarly associate a class with a built-in <code>Source</code> interface, and inject an instance of it provided by Spring Cloud Stream.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">@EnableBinding(Source.class)
public class SourceExample {

	@Autowired
	private Source source;

	public void sendMessage() {
		this.source.output().send(new GenericMessage&lt;&gt;(/* your object here */));
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_streaming_vs_polled_input"><a class="link" href="#_streaming_vs_polled_input">Streaming vs. Polled Input</a></h3>
<div class="paragraph">
<p>Many Spring Cloud Stream applications will use the built-in <code>Sink</code> binding, which triggers the <em>streaming</em> input binder creation.
Messages can then be consumed with an input handler marked by <code>@StreamListener(Sink.INPUT)</code> annotation, at whatever rate Pub/Sub sends them.</p>
</div>
<div class="paragraph">
<p>For more control over the rate of message arrival, a polled input binder can be set up by defining a custom binding interface with an <code>@Input</code>-annotated method returning <code>PollableMessageSource</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface PollableSink {

	@Input("input")
	PollableMessageSource input();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PollableMessageSource</code> can then be injected and queried, as needed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@EnableBinding(PollableSink.class)
public class SinkExample {

    @Autowired
    PollableMessageSource destIn;

    @Bean
    public ApplicationRunner singlePollRunner() {
        return args -&gt; {
            // This will poll only once.
            // Add a loop or a scheduler to get more messages.
            destIn.poll(message -&gt; System.out.println("Message retrieved: " + message));
        };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the polling will only get 1 message at a time.
Use the <code>spring.cloud.stream.gcp.pubsub.default.consumer.maxFetchSize</code> property to fetch additional messages per network roundtrip.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sample"><a class="link" href="#_sample">Sample</a></h3>
<div class="paragraph">
<p>Sample applications are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For <a href="https://github.com/GoogleCloudPlatform/spring-cloud-gcp/tree/main/spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-stream-sample">streaming input, annotation-based</a>.</p>
</li>
<li>
<p>For <a href="https://github.com/GoogleCloudPlatform/spring-cloud-gcp/tree/main/spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-stream-functional-sample">streaming input, functional style</a>.</p>
</li>
<li>
<p>For <a href="https://github.com/GoogleCloudPlatform/spring-cloud-gcp/tree/main/spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-stream-polling-sample">polled input</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</body>
</html>